---
title: "Applied example with package missmeta"
author: "Irene Alfarone"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Meta-analysis of psychotherapies and depression
The goal of the present markdown is to show the use of missmeta to impute missing
outcomes in bivariate meta-analysis under different missigness assumptions. 

### Dataset
Data are gathered from Cujipers et al. (2010) published meta-analysis on the differences between CR and SR depression measurements. The authors collect data from 48 studies that measure depression on both a clinician rating (HRSD) and self-report scale (BDI). The meta-analysis highlights a substantial difference between the patients’ and clinicians’ evaluations of depression, in favor of the clinician rating.


```{r data, message = FALSE}
library(readxl)
library(dplyr)

d = read_xlsx("cujipersetal-data2.xlsx", sheet = "Sheet2")

d <- d %>%
  mutate(
    across(c(-Study, -Psychotherapy), as.numeric),
    MissHRSD=ifelse(is.na(`T-HRSD-M-Post`), "0", "1"),
    MissBDI=ifelse(is.na(`T-BDI-M-Post`), "0", "1"),
    across(c(Psychotherapy), as.factor)
  )

df <- d[-c(2, 4, 7, 13, 17, 19, 21, 27, 31, 34, 36, 37, 38, 45, 48, 56, 58, 59),]

df$EstSR <- df$`T-BDI-M-Post` - df$`C-BDI-M-Post`
df$EstCR <- df$`T-HRSD-M-Post` - df$`C-HRSD-M-Post`

Spooled <- function(Nt, sdt, Nc, sdc)
{
  sqrt(((Nt-1)*sdt^2 + (Nc-1)*sdc^2)/((Nt-1)+(Nc-1)))
}

BDI_sp <- Spooled(df$Nt, df$`T-BDI-SD-Post`, df$Nc, df$`C-BDI-SD-Post`)
df$SESR <- BDI_sp * sqrt((1/df$Nt)+(1/df$Nc))


HRSD_sp <- Spooled(df$Nt, df$`T-HRSD-SD-Post`, df$Nc, df$`C-HRSD-SD-Post`)
df$SECR <- HRSD_sp * sqrt((1/df$Nt)+(1/df$Nc))

dmnar = df[,c("Study", "N", "EstCR", "SECR", "EstSR", "SESR")]
dmnar$Cor.ws = 0.7
dmnar$Cor.ws[is.na(dmnar$EstCR) | is.na(dmnar$EstSR)] = NA
head(dmnar)
```

## Imputing data using function from missmeta

### Prepare the distributions

```{r distr}
library(missmeta)
library(tmvtnorm)
library(mvtnorm)

unif1 <- function(n) runif(n, min = -11, max = 11)
unif2 <- function(n) runif(n, min = -11, max = 11)

norm01 <- function(n) rnorm(n, mean = 0, sd = 6)
norm02 <- function(n) rnorm(n, mean = 0, sd = 6)

norm61 <- function(n) rnorm(n, mean = 6, sd = 6)
norm62 <- function(n) rnorm(n, mean = 6, sd = 6)

normn61 <- function(n) rnorm(n, mean = -6, sd = 6)
normn62 <- function(n) rnorm(n, mean = -6, sd = 6)

sigma = matrix(c(6^2,
                 CorCov(6,6,0.7), 
                 CorCov(6,6,0.7), 
                 6^2), nrow = 2)

lower = c(-100, -100)
upper = c(100, 100)

mtv1 = function(n) rtmvnorm(n, mean = c(-6, -6), sigma = sigma, lower = lower, upper = upper)[,1]
mtv2 = function(n) rtmvnorm(n, mean = c(-6, -6), sigma = sigma, lower = lower, upper = upper)[,2]

```

### Impute under different scenarios

```{r genimp}
imp1 <- list(unif1, norm01, norm61, normn61, mtv1)
imp2 <- list(unif2, norm02, norm62, normn62, mtv2)

imp1 <- list(norm01)
imp2 <- list(norm02)

out <- mapply(function(i1, i2) {
  genimp(
    df = dmnar,
    iter = 1000,
    imp1 = i1,
    imp2 = i2,
    eff1 = "EstCR",
    eff2 = "EstSR",
    se1 = "SECR",
    se2 = "SESR",
    cor = "Cor.ws",
    N = "N",
    imprho = 0.6
  )
}, i1 = imp1, i2 = imp2, SIMPLIFY = FALSE)

```

### Compute meta-analysis for each imputed dataset

```{r makemeta}
library(mixmeta)

outls = unlist(out, recursive = FALSE)

res = lapply(outls, function(data) {
  theta = cbind(data$EstCR, data$EstSR)
  Sigma = cbind(data$SECR^2, CorCov(data$SECR, data$SESR, data$Cor.ws), data$SESR^2)
  
  m = mixmeta(theta, S = Sigma, method = "reml")
  s = summary(m)
  ci = confint(m)
  
  results = data.frame(
  eff1 = s$coefficients[1,1],
  eff2 = s$coefficients[2,1],
  se1 = s$coefficients[1, 2],
  se2 = s$coefficients[2, 2],
  cov12 = s$vcov[1, 2],
  ci.lb1 = ci[1, 1], ci.ub1 = ci[1, 2],
  ci.lb2 = ci[2, 1], ci.ub2 = ci[2, 2]
  )
  
})

res <- do.call(rbind, res)

res <- split(res,  rep(1:5, each=5))
```

## Summarize results for imputed datasets

```{r sum_meth}
resuni = do.call(rbind, res[[1]])
resnorm0 = do.call(rbind, res[[2]])
resnorm6 = do.call(rbind, res[[3]])
resnormn6 = do.call(rbind, res[[4]])
resmtv = do.call(rbind, res[[5]])

eff1 <- list(resuni$eff1, resnorm0$eff1, resnorm6$eff1, resnormn6$eff1, resmtv$eff1)
eff2 <- list(resuni$eff2, resnorm0$eff2, resnorm6$eff2, resnormn6$eff2, resmtv$eff2)

se1 <- list(resuni$se1, resnorm0$se1, resnorm6$se1, resnormn6$se1, resmtv$se1)
se2 <- list(resuni$se2, resnorm0$se2, resnorm6$se2, resnormn6$se2, resmtv$se2)

cov12 <- list(resuni$cov, resnorm0$cov, resnorm6$cov, resnormn6$cov, resmtv$cov)

method <- list("Uniform (-30, 30)", "Normal CR = 0, SR = 0", "Normal CR = 6, SR = 6",
               "Normal CR = -6, SR = -6", "Multivariate Normal (-6, -6)")

sum.res <- mapply(function(eff1, eff2, se1, se2, cov12, method) {
  
  sum_meth(eff1, eff2, se1, se2, cov12, method)

},  eff1 = eff1, eff2 = eff2, se1 = se1, se2 = se2, cov12 = cov12,
 method = method, SIMPLIFY = FALSE)

sum.res <- do.call(rbind, sum.res)
rownames(sum.res) <- NULL
sum.res

```

## Plot the results for nice representation


```{r plot.res}
library(ggplot2)

ggplot(sum.res, aes(x = method)) +
  geom_linerange(aes(ymin = ci1_lb, ymax = ci1_ub), linewidth = 1.5) +
  geom_point(aes(y = eff1), color = "black", size = 3) +
  geom_hline(yintercept = -6.0604, linetype = "dashed", color = "#A4031F") +
  coord_flip() +
  labs(
    title = "Uncertainty Intervals for HRSD",
    x = "Method", y = "HRSD Interval"
  ) +
  theme_minimal()

ggplot(sum.res, aes(x = method)) +
  geom_linerange(aes(ymin = ci2_lb, ymax = ci2_ub), linewidth = 1.5) +
  geom_point(aes(y = eff2), color = "black", size = 3) +
  geom_hline(yintercept = -6.4751, linetype = "dashed", color = "#A4031F") +
  coord_flip() +
  labs(
    title = "Uncertainty Intervals for BDI",
    x = "Method", y = "BDI Interval"
  ) +
  theme_minimal()

```